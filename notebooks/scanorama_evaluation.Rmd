---
jupyter:
  jupytext_format_version: '1.0'
  kernelspec:
    display_name: Python [conda env:single_cell_integration]
    language: python
    name: conda-env-single_cell_integration-py
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.6.6
---

```{python}
import numpy as np
import scipy as sp
import scanpy.api as sc
import pandas as pd
import anndata
from pylab import subplots
import MulticoreTSNE
```

```{python}
mcp_sig = pd.read_csv("../tables/mcp_counter_signatures.txt", sep="\t")
```

```{python}
tmp = np.genfromtxt("../tables/regev_lab_cell_cycle_genes.txt", dtype='str')
cell_cycle_genes = {
    "s": tmp[:43],
    'g2m': tmp[43:]
}
```

```{python}
dataset_tab = pd.read_csv("../tables/datasets.tsv", sep="\t")
dataset_map = dataset_tab.set_index('path').to_dict(orient='index')
```

```{python}
# scanorama_tsne = np.load("../results/scanorama/")['arr_0']
datasets_dimred = np.load("../results/scanorama/datasets_dimred.npz")['arr_0']
datasets = np.load("../results/scanorama/datasets.npz")['arr_0']
```

```{python}
genes = np.genfromtxt("../results/scanorama/genes.txt", dtype="str")
labels = np.genfromtxt("../results/scanorama/labels.txt", dtype='int')
label_names = np.genfromtxt("../results/scanorama/label_names.txt", dtype='str')
label_names = np.array([l.replace('results/data_processed/', '') for l in label_names])
labels_id = np.array([dataset_map[label_names[i]]['id'] for i in labels])
```

```{python}
# concatenate the matrices into a large single matrix
scanorama_dimred = np.concatenate(datasets_dimred)
scanorama = sp.sparse.vstack(datasets)
scanorama.shape
```

```{python}
assert scanorama.shape[0] == scanorama_dimred.shape[0] == labels.shape[0] == labels_id.shape[0]
assert scanorama.shape[1] == genes.shape[0]
```

## Prepare data for scanpy

```{python}
fdata = pd.DataFrame().assign(gene_symbol = genes).set_index('gene_symbol')
```

```{python}
pdata = pd.DataFrame().assign(source = labels_id)\
                      .assign(cell_id = ["cell_{}".format(i) for i in range(len(labels_id))])\
                      .set_index("cell_id")
```

# Initial quality control
*check if data clusters by cell type and not by other confounders*

* color by
    - cell cycle labels
    - n_detected_genes
    - sum of pathway genes
    
* "overdispersed genes"? 
* tSNE vs. PCA
* doublet detection? 

### Notes
- use griph to detect cell cycle genes


```{python}
adata = anndata.AnnData(scanorama, var=fdata, obs=pdata)
adata.shape
```

```{python}
sc.pl.highest_expr_genes(adata, n_top=20)
```

```{python}
sc.pp.filter_cells(adata, min_genes=100)
```

```{python}
adata.shape
```

```{python}
sc.pp.filter_genes(adata, min_cells=3)
```

```{python}
adata.shape
```

```{python}
mito_genes = [name for name in adata.var_names if name.startswith('MT-')]
# for each cell compute fraction of counts in mito genes vs. all genes
# the `.A1` is only necessary as X is sparse to transform to a dense array after summing
adata.obs['percent_mito'] = np.sum(
    adata[:, mito_genes].X, axis=1).A1 / np.sum(adata.X, axis=1).A1
# add the total counts per cell as observations-annotation to adata
adata.obs['n_counts'] = adata.X.sum(axis=1).A1
```

```{python}
sc.pl.violin(adata, ['n_genes', 'n_counts', 'percent_mito'],
             jitter=0.4, multi_panel=True)
```

```{python}
sc.pl.scatter(adata, x='n_counts', y='n_genes', color="source")
```

```{python}
sc.tl.score_genes_cell_cycle(adata, s_genes=cell_cycle_genes['s'], g2m_genes=cell_cycle_genes['g2m'])
```

## Embeddings
### PCA

```{python}
sc.tl.pca(adata, svd_solver='arpack')
```

```{python}
sc.pl.pca(adata, color='source')
```

```{python}
sc.pl.pca_variance_ratio(adata, log=False)
```

### UMAP

```{python}
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)
```

```{python}
sc.tl.umap(adata)
```

```{python}
fig, ax = subplots(figsize=(10, 6))
sc.pl.umap(adata, color="source", ax=ax)
```

### t-SNE

```{python}
sc.tl.tsne(adata, n_jobs=32)
```

```{python}
fig, ax = subplots(figsize=(10, 6))
sc.pl.umap(adata, color="source", ax=ax)
```

## Clustering

```{python}
sc.tl.louvain(adata)
```

```{python}
sc.pl.umap(adata, color=['louvain'])
```

## Cell type detection (using MCP counter)

```{python}
cell_types = mcp_sig["Cell population"].unique()
```

```{python}
for ct in cell_types:
    tmp_genes = mcp_sig["HUGO symbols"][mcp_sig["Cell population"] == ct].values
    tmp_genes = np.array([g for g in tmp_genes if g in adata.var_names])
    print(ct)
    print(tmp_genes)
    idx = np.where(adata.var_names.isin(tmp_genes))[0]
    score_per_cell = np.sum(adata.X[:, idx], axis=1)
    adata.obs[ct] = score_per_cell
```

```{python}
for ct in cell_types:
    sc.pl.umap(adata, color=ct)
```

```{python}

```
