---
params:
  input_file: NULL
  output_file: NULL
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.5
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.6.7
---

```{python}
import pandas as pd
import scanpy.api as sc
import numpy as np
from matplotlib import pyplot as plt
import os
import sys
import gc
sys.path.append("lib")
from jupytertools import setwd
from scio import concatenate
from scpp import norm_log
setwd()
```

```{python}
biomart = pd.read_csv("tables/biomart.tsv", sep="\t")
```

```{python}
# OUT_FILE = "results/data_merged/adata.h5ad"
OUT_FILE = r.params["output_file"]
INPUT_FILE = r.params["input_file"]
```

```{python load_adata, message=FALSE}
adata = sc.read_h5ad(INPUT_FILE)
```

## Normalize and scale

The `raw` data object will contain normalized, log-transformed values for visualiation. 
The original, raw (UMI) counts are stored in `adata.obsm["raw_counts"]`. 

```{python}
norm_log(adata)
```

## Determine cell cycle score (on full dataset)

```{python}
cell_cycle_regev = pd.read_csv("tables/cell_cycle_regev.tsv", sep="\t")
cell_cycle_regev = cell_cycle_regev[["hgnc_symbol", "phase"]].drop_duplicates()
```

```{python}
sc.tl.score_genes_cell_cycle(adata,
                             s_genes = cell_cycle_regev.loc[cell_cycle_regev["phase"] == "S","hgnc_symbol"].values,
                             g2m_genes = cell_cycle_regev.loc[cell_cycle_regev["phase"] == "M","hgnc_symbol"].values)
```

Use the 'alternative strategy' for cell cycle effect removal from the [seurat tutorial](https://satijalab.org/seurat/cell_cycle_vignette.html#assign-cell-cycle-scores). If we regress out all effects, we might loose valuable information about dividing/non-dividing exhausted/effective T cells.

```{python}
adata.obs["cell_cycle_diff"] = adata.obs["S_score"] - adata.obs["G2M_score"]
```

```{python}
cc_genes = cell_cycle_regev.loc[cell_cycle_regev["hgnc_symbol"].isin(adata.var_names), "hgnc_symbol"]
adata_cc_genes = adata[:, cc_genes]
sc.tl.pca(adata_cc_genes)
sc.pl.pca_scatter(adata_cc_genes, color=['phase'])
```

## Detect highly variable genes.
Most batch effect removal tools rely on the fact that data has been
filtered for highly variable genes. We do this filtering here, on the merged data only,
for the same reason we use the outer join above:

In the datasets that only contain T cells, lineage specific markers (e.g. CD8A) would
not be selected as highly variable and therefore discarded.

```{python}
filter_result = sc.pp.filter_genes_dispersion(adata.X, flavor="seurat", min_mean=0.0125, max_mean=3, min_disp=0.5)
```

```{python}
sc.pl.filter_genes_dispersion(filter_result, log=False)
```

```{python}
adata = adata[:, filter_result.gene_subset]
```

# visualize confounders

```{python pca}
sc.tl.pca(adata, svd_solver='arpack')
```

```{python}
sc.pl.pca(adata, color=["n_genes", "n_counts", "percent_mito", "phase", "dataset", "patient", "origin"], ncols=2)
```

```{python}
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)
sc.tl.umap(adata)
```

```{python}
sc.pl.umap(adata, color=["n_genes", "n_counts", "percent_mito", "phase", "dataset", "patient", "origin", "platform"], ncols=2)
```

# Remove confounders

```{python regress-out-cell-cycle}
sc.pp.regress_out(adata, ['cell_cycle_diff', "percent_mito", "n_counts", "n_genes"])
sc.pp.scale(adata, zero_center=True)
```

## Visualize confounders after removal

```{python vis-cc}
cc_genes = cell_cycle_regev.loc[cell_cycle_regev["hgnc_symbol"].isin(adata.var_names), "hgnc_symbol"]
adata_cc_genes = adata[:, cc_genes]
sc.tl.pca(adata_cc_genes)
sc.pl.pca_scatter(adata_cc_genes, color=['phase'])
```

```{python umap}
sc.tl.pca(adata, svd_solver='arpack')
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)
sc.tl.umap(adata)
```

```{python}
sc.pl.pca(adata, color=["n_genes", "n_counts", "percent_mito", "phase", "dataset", "patient", "origin"], ncols=2)
```

```{python}
sc.pl.umap(adata, color=["n_genes", "n_counts", "percent_mito", "phase", "dataset", "patient", "origin"], ncols=2)
```

# save result
```{python write-results}
adata.write(OUT_FILE, compression="lzf")
adata.write_csvs(os.path.dirname(OUT_FILE))
```

